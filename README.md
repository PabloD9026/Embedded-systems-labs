# Embedded-systems-labs

Лабораторные работы по дисциплине встраиваемые системы

Отчёты доступны по ссылкам:
  
  1.https://drive.google.com/file/d/1BM94UvZRSnQPHgVjrORH7YOFdb20vaOR/view?usp=sharing
  
  2.https://drive.google.com/file/d/1ggV7BJlKY50FrM14OajgCatzP2kFacVS/view?usp=sharing

# Лабораторная работа №1 - Знакомство с SPI

# Задача

Получение передачи данных с помощью интерфейса передачи данных SPI между 4-ями устройствами на базе STM32. 

# SPI - Serial Peripheral Interface

Название интерфейс SPI является аббревиатурой от “Serial Peripheral Bus”, что можно перевести как “шина для подключения периферийных устройств”. Отсюда вытекает ее главное назначение - связать одно главное устройство - Ведущее (Master) - с одним или несколькими Ведомыми (Slave). Ведущий в этом интерфейсе всегда один, только он руководит всем процессом, и только он может формировать тактовые импульсы. Если в нашем случае Ведущим всегда является микроконтроллер (эту роль может исполнять и компьютер, но это другая история), то Ведомыми в подавляющем большинстве случаев являются именно периферические устройства. Датчики, дисплеи, микросхемы ЦАП и АЦП, RFID-ридеры, модули беспроводной связи, включая приемо-передатчики WiFi и Bluetooth, GPRS-адаптеры и так далее. Особенно этот интерфейс востребован там, где требуется высокая скорость передачи данных и не менее высокая надежность. SPI именно такой, он самый быстрый из всех имеющихся в нашем распоряжении и самый “легкий” с точки зрения потребляемых ресурсов. Расплатой за это является использование большего количеств проводов, чем для других интерфейсов. Здесь требуется 3 штуки только непосредственно для передачи данных:

  •	MOSI - Master Output Slave Input (Ведущий передает, Ведомый принимает).
  
  •	MISO - Master Input Slave Output (Ведущий принимает, Ведомый передает).
  
  •	SCLK, иначе SCK - Serial Clock (тактовый сигнал).

Есть три способа подключения Ведущего и Ведомых.

  •	Первый: если Ведомый один, одноименные пины просто соединяются напрямую. 
  
  •	Второй: классический. Несколько Ведомых соединяются с Ведущим параллельно шинами MISO, MOSI и SCK, а SS ведет к каждому из них индивидуально.
  
  •	Третий: цепочка, он же кольцо. SS один на всех, но данные передаются как бы сквозь устройства с одного на другое. Пока SS в низком уровне, данные растекаются по своим местам, после подъема уровня SS, устройства начинают с принятыми данными работать. 

Как было выше сказано, интерфейс передачи данных SPI – синхронный. Это означает, что он использует отдельные линии для данных и «тактирование», которое обеспечивает идеальную синхронизацию обеих сторон. Тактовый сигнал представляет собой колебательный сигнал, который точно сообщает приемнику, когда следует производить выборку битов в линии данных. Это может быть нарастающий (от низкого к высокому) или падающий (от высокого к низкому) фронт тактового сигнала. Когда приемник обнаруживает этот фронт, он немедленно смотрит на строку данных, чтобы прочитать следующий бит. Поскольку тактирование передаётся вместе с данными, указание скорости не имеет значения, хотя устройства будут иметь максимальную скорость, с которой они могут работать. Схема показана ниже:

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/f2b708e3-bbe3-42c6-bd11-0e4dcffafd7a)

# Выполнение работы

В рамках этой лабораторной работы был использован классический способ подключения SPI, где для каждого ведомого предназначен и подключен к нему SS пин. 

В качестве мастера был произвольно выбран микроконтроллер STM32103C8T6 или bluepill.его распиновка показана ниже:

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/f85a9252-0255-4327-9ce8-64cd4fbb5568)

и его настройки:

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/6e421f07-35bd-4a5d-ba4e-ce556142fc7c)

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/bab42787-5658-49a9-a926-b4ee2c0ddb6e)

Пины SS – PA1, PA2 и PA4 для slave1, slave2 и slave3 соответственно. Так же на рисунке можно посмотреть, что прерывание было подключено. Это было сделано для того, чтобы не нагружать микроконтроллер, а чтобы он только занимался передачей данных, когда надо.

Потом для всех SS пинов, была настроена максимальная скорость переключения, и чтобы начальное состояние пинов было HIGH или логический 1.

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/98231520-67c6-45a1-a66d-57065f5aaaec)

В качестве Slave были использованы платы STM32 Nucleo 144 на базе STM32F429ZIT6, так как все имеют одинаковые настройки только будет показан один пример настроек.

Распиновка

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/0cb43a50-aba0-4feb-bd7a-2124249eb599)

Где пин PB14 это светодиод, которым управляем с мастера через SPI.

Настройки

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/0f60ef12-05f0-4051-ad8b-026fe9328de8)

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/49c11c0d-f1ff-400d-a753-2da7596d04de)

В настройках Slave микроконтроллеров была включена функция Hardware NSS Signal для того, чтобы микроконтроллер начал автоматический принять данные при сигнале мастера.

Схема подключения электроники сделана по схеме показана ниже

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/f431f20a-6975-4ff7-8f88-1f75d365fc90)

С помощью SPI были отправлены массивы с Мастера и Slave. В массиве было указано каким, из двух светодиодов встроенных на плате, управлять. 

Результат работы: https://drive.google.com/file/d/1qirZOv0wFrJxRqvNCVRArRhHjq-4NsMO/view?usp=sharing


# Лабораторная работа №2 - Знакомство с USB

В ходе данной работы необходимо связать микроконтроллеры на бызе STM32 посредством USB подключения.

Необходимо отрисовывать апериодическое звено 2-го порядка на светодиодной панели P10 посредством передачи сигналов по SPI с отладочной платы STM32 BluePill, которая в свою очередь получает значения функции по USB соединению из другой платы STM32 Bluepill. Должна быть возможность вносить в систему возмущение посредством нажатия кнопки.

Для выполнения задания необходимо изучить принцип работы USB соединения и P10 светодиодную панель.

# USB - Universal Serial Bus

# Принцип работы USB
Протокол шины USB обеспечивает обмен данными между хостом и устройством. На протокольном уровне решаются такие задачи, как обеспечение достоверности и надежности передачи, управление потоком. Весь трафик на шине USB передается посредством транзакций, в каждой транзакции возможен обмен только между хостом и адресуемым устройством (его конечной точкой). Все транзакции (обмены) с устройствами USB состоят из двух-трех пакетов, типовые последовательности пакетов в транзакциях приведены ниже. Каждая транзакция планируется и начинается по инициативе хост-контроллера, который посылает пакет-маркер транзакции (token packet). Маркер транзакции описывает тип и направление передачи, адрес выбранного устройства USB и номер конечной точки. Адресуемое маркером устройство распознает свой адрес и готовится к обмену. Источник данных, определенный маркером, передает пакет данных. На этом этапе транзакции, относящиеся к изохронным передачам, завершаются — здесь нет подтверждения приема пакетов. Для остальных типов передач работает механизм подтверждения, обеспечивающий гарантированную доставку данных. Форматы пакетов приведены ниже, типы пакетов — ниже. Во всех полях пакетов, кроме поля CRC, данные передаются младшим битом вперед (на временных диаграммах младший бит изображается слева). Пакет начинается с синхропоследовательности Sync и завершается признаком конца — EOP. Тип пакета определяется полем PID. Назначение остальных полей раскрывается далее. Длина полей Sync и EOP указана для передач на FS/LS, для высокоскоростных передач поле Sync удлинено до 32 битовых интервалов, а EOP до 8 (в пакетах SOF поле EOP имеет длину 40 бит).

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/7d05ef4a-1267-48ba-acd9-7aa48b4ff6dd)

где, а – вывод и б – ввод данных

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/5eb7a8de-17a6-475c-9598-ef36a5e2d489)

где, а – маркер, ю = пакет данных, в – пакет квитирования

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/598cb4bd-fa38-4a86-8ebb-b5e3d8e2bdf2)

Типы пакетов и их идентификаторы PID

Все принимаемые пакеты проверяются на наличие ошибок, что позволяют принятые форматы пакета и некоторые соглашения: пакет начинается с синхронизирующей последовательности, за которой следует его идентификатор PID (Packet Identificator). За идентификатором следует его инверсная копия — Check. Несовпадение двух копий считается признаком ошибки; тело пакета (все поля пакета, исключая PID и признак EOP) защищается CRCкодом: 5-битным для пакетов-маркеров, 16-битным — для пакетов данных. Несовпадение CRC с ожидаемым значением считается признаком ошибки; пакет завершается специальным сигналом EOP; если в пакете оказывается не целое число байт, он считается ошибочным. Ложный EOP, даже на границе байта, не позволит принять пакет из-за практически неизбежной в данной ситуации ошибки по CRC-контролю; на физический уровень (в шину) данные пакета передаются с использованием вставки бит (bit stuffing, после шести единичных бит вставляется нолик), что предотвращает потерю битовой синхронизации при монотонном сигнале. Прием более шести единичных бит подряд считается ошибкой (на HS — признаком конца кадра). Обнаружение любой из перечисленных ошибок в пакете заставляет приемник считать его недействительным. На пакеты, принятые с ошибкой, ни устройство, ни хост-контроллер никак не отвечают. При изохронной передаче данные недействительного пакета должны просто игнорироваться (они теряются); для остальных типов передач используются средства обеспечения надежной доставки.

SB — это интерфейс с одной информационной линией, что означает, что приём и передача информации могут проходить только поочерёдно. Два сигнальных провода физически выполненные в виде витой пары, передают один и тот же информационный сигнал, и представляют собой так называемое симметричное или балансное подключение, распространённое в связи и профессиональном звуке.
Для чего же оно нужно и как оно работает? Для начала. Чем симметричная линия отличается от несимметричной? Схема показана ниже:

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/1fc75a66-8879-4ae9-b416-9f57175afa42)

В обеих роль источника сигнала играет аккумулятор BAT1, роль принимающей стороны - вольтметр BM1. Были использован в этом примере источник постоянного тока, т.к. цифровой сигнал в USB кабеле — это, тоже, постоянные уровни, которые с течением времени сменяют друг друга. Различие схем, на первых взгляд, несущественно, однако, если приглядеться, можно заметить, что в симметричной схеме минусовая линия подключена к оплётке и заземлена, то есть оплётка, по сути, является одним из проводников кабеля.

Если кабели оказались в зоне действия помехи. Провода кабелей окажутся под действием магнитного поля, в результате чего в них возникает явление электромагнитной индукции, то есть появится ЭДС, которая внесёт искажения в полезный сигнал.

Описанное явление называется помехой. Если рассуждать о сути протекающих в кабеле физических процессов, можно сказать, что кабель в этой ситуации ведёт себя подобно обмотке трансформатора, которая, под воздействием магнитного поля сердечника, также вырабатывает ЭДС. А значит для того, чтобы смоделировать ситуацию воздействия помехи на кабель, достаточно заменить его провода трансформаторами.

Полезный сигнал, обычно при помощи инвертора, транслируется в противофазе – плюс аккумулятора, минус аккумулятора. Помеха – хоть емкостная, хоть электромагнитная – воздействует синфазно, то есть с одинаковой фазой и в одинаковой полярности на оба проводника. На выходе схемы устанавливается дифференциальный усилитель показан ниже:

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/459ccd75-12dc-40d1-ba17-14e5a54ff7ce)

В результате, если полезный сигнал, имеет на двух проводниках потенциал +2 и -2 вольта соответственно, результатом вычисления будет число 4. Помеха же, имеющая потенциал +3 и -3 вольта, то есть, одинаковый на обоих проводниках, будет иметь результирующее значение, равное нулю, как показано ниже. При этом, что ЭДС помехи вырабатывается в обеих сигнальных линиях, это никак не заметно на принимающей стороне. Если передавать цифровой сигнал – нули и единички, они точно так же, без искажений достигали своей цели, невзирая на наличие синфазной помехи. Именно такую методичку передачи сигнала и использует стандарт USB.

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/34edf2d4-c7cd-475b-abe2-386b4a5bd651)

Для передачи логических битов USB использует метод NRZI (non-return-to-zero inverted). Он состоит в том, что логический 1 будет принят, когда сигнал остается на том же уровне, а логический 0 когда сигнал меняется с течением времени. Схема показана ниже 

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/5b514acf-82d9-4c5d-86c5-3de5b43264d2)


# P10 Светодиодная панель

P10 Светодиодная панель или P10 Led Board представляет собой панель состоящую из корпуса, светодиодов и управляющих микросхем. Размерность светодиодной панели в пикселях равна 16 по высоте и 32 по ширине. Управление светодиодной панелью осуществляется через интерфейс SPI, что позволяет подключать несколько панелей последовательно и масштабиовать размерность панели.

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/230f2659-26ea-4239-9b96-57cc598d365f)

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/611f7046-9bf6-4dc3-86a0-c60d3860895a)

Распиновка входного разъёма

![image](https://github.com/PabloD9026/Embedded-systems-labs/assets/91127156/b3065a55-d843-4ee5-a29f-c43101d15114)

На разъёме:

  Пины 6, 14, 16 (C, G, D) — не используются (возможно они используются в 3-цветных матрицах).
  
  Пины 2 и 4 (A и B) — задают, какая из 4 групп светодиодов экрана работает в данный момент. Матрицы используют динамическую индикацию, поочерёдно переключая 4 группы светодиодов в зависимости от логических уровней на ножках A и B. На плате эти сигналы приходят на дешифратор D18, который открывает 1 из 4 групп P-канальных полевиков, тем самым подавая +5В на аноды светодиодов выбранной группы.
  
  Пин 1 (nOE) — разрешает работу матрицы (лог. 0 гасит все матрицы в цепочке). Логика работы этого пина реализована на элементах НЕ в D19 и дешифраторе D18.
  
  Пины 8 и 12 (CLK и R) — линии клока и данных синхронного последовательного интерфейса. Их подключаем к SCK и MOSI интерфейса SPI микроконтроллера.
  
  Пин 10 (SCLK) — по переднему фронту защёлкивает переданные в сдвиговые регистры данные на их выходы. Сдвиговые регистры подключены к катодам светодиодов матрицы. По этой причине передаваемые данные нужно инвертировать (светодиод будет гореть при лог. 0)
  














Результат работы:
https://drive.google.com/file/d/1QFM6ang3bwelZnacgG3ITa8YgUQOJIV4/view?usp=sharing

